linear data structure-where data elements are arranged sequentially, 
meaning each element is connected to its previous and next elements

stores data in nodes which are connected by pointers

NOT stored in contiguous memory-a blocked of memory where
data is stored sequential,adjacent locations
the memory for a particular process or data structure is allocated as a single,
unbroken chunk,rather than being scattered across the memory space. 

can only be accessed sequentially, starting from the head of list.

used to implement other data structures like stack,
queue and deque

insertion and deletion is efficient than array

Linked List:
Data Structure: Non-contiguous
Memory Allocation: Typically allocated one by one to individual elements
Insertion/Deletion: Efficient
Access: Sequential

Array:
Data Structure: Contiguous
Memory Allocation: Typically allocated to the whole array
Insertion/Deletion: Inefficient
Access: Random


- each node contains a data field and a         
reference to the next node in the linked list
- The next of the last node is null

doubly linked list---> each node in the list contains a pointer to the 
previous node and a pointer to the next node. 

This allows for quick and easy insertion and deletion of nodes from the 
list, as well as efficient traversal of the list in both directions.



/*
linked is the concept where we caan add elements dynamically
address of each element may be not in sequence

for each element(node-elemnet of linked list)
two componenets:
-value of it
-address of next element

types of liniked list:
-single linked list
-single-circular list
-doubly linked list--for each node
    --data
    --addrees of previous elment
    --address of next element
-double-circular list

destructor-fn hyyy2                 aving same name as the class/constructor to destroy the objects from memomry also

class Node{
    char data;
    Node* next;
    
}
*/

/*
#include<iostream>
using namespace std;

class Node {
public:
    char data;
    Node* next;
    Node(char data) {
        this->data = data;
        this->next = NULL;
    }
    void printNode() {
        cout << (this->data) << endl;
    }
};

class SingleLinkedList {
public:
    Node* head;
    SingleLinkedList() {
        this->head = NULL;
    }
   
    void insertEnd(char d) {
        Node* nn = new Node(d); // Dynamically allocate the new node
        Node* curr;
        if (head != NULL) {
            curr = head;
            while (curr->next != NULL) {
                curr = curr->next;
            }
            curr->next = nn; // Link the new node
        } else {
            head = nn; // Set head to the new node if list is empty
        }
    }
    void printList() {
        cout << "Printing the list" << endl;
        Node* curr = head;
        while (curr != NULL) {
            curr->printNode();
            curr = curr->next;
        }
    }
    // Add a destructor to free memory
    ~SingleLinkedList() {
        Node* curr = head;
        while (curr != NULL) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
    }
};

int main() {
    SingleLinkedList list;
    list.insertEnd('A');
    list.printList();
    list.insertEnd('B');
    list.printList();
    list.insertEnd('C');
    list.printList();
    return 0;
}*/